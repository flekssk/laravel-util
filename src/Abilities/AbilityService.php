<?php

declare(strict_types=1);

namespace FKS\Abilities;

use ReflectionClass;
use FKS\Abilities\Contracts\AbilitiesResolverInterface;
use FKS\Abilities\ValueObjects\AbilitiesConfig;
use FKS\Abilities\ValueObjects\AbilityMethod;

class AbilityService
{
    /**
     * @param AbilitiesResolverInterface[] $abilitiesResolvers
     */
    public function __construct(
        private readonly array $abilitiesResolvers,
        private readonly AbilitiesConfig $abilitiesConfig,
    ) {}

    public function getAllAbilitiesList(): array
    {
        $abilities = [];

        foreach ($this->abilitiesResolvers as $abilitiesResolver) {
            $reflection = new ReflectionClass($abilitiesResolver);
            foreach ($reflection->getMethods() as $method) {
                if ($method->isPublic() && $method->getName() !== '__construct') {
                    $abilities[$abilitiesResolver::class][] = new AbilityMethod(
                        $method->getName(),
                        $method->getParameters(),
                        $method->getReturnType()
                    );
                }
            }
        }

        return $abilities;
    }

    public function generateFacade(): bool
    {
        $directory = dirname($this->abilitiesConfig->facadeClassPath);
        if (!is_dir($directory)) {
            mkdir($directory, 0755, true);
        }

        $template = $this->getFacadeTemplate();
        $content = $this->replacePlaceholders($template);

        if (!is_dir(rtrim($this->abilitiesConfig->facadeClassPath))) {
            mkdir(rtrim($this->abilitiesConfig->facadeClassPath), 0755, true);
        }

        return file_put_contents(rtrim($this->abilitiesConfig->facadeClassPath) . '/AbilityFacade.php', $content) !== false;
    }

    protected function getFacadeTemplate(): string
    {
        return <<<'EOT'
            <?php

            declare(strict_types=1);

            namespace App\Facades;

            use FKS\Abilities\Facade\AbilityFacade as BaseAbilityFacade;

            /**
             * NOTICE! This is autogenerated class
             * 
             * Run 'php artisan abilities:generate-facade' to collect all classes implemented AbilitiesResolverInterface and build Facade
             *
             * {{METHODS}}
             */
            class AbilityFacade extends BaseAbilityFacade
            {
                public static array $abilities = [
                    {{ABILITIES}}
                ];

                public static function getAbilities(): array
                {
                    return static::$abilities;
                }
            }
            EOT;
    }

    private function replacePlaceholders(string $template): string
    {
        $replacements = [
            '{{METHODS}}' => implode(PHP_EOL . ' * ', $this->buildMethodsAnnotations()),
            '{{ABILITIES}}' => implode(PHP_EOL . '        ', $this->buildAbilitiesArray()),
        ];

        return str_replace(
            array_keys($replacements),
            array_values($replacements),
            $template
        );
    }

    private function buildMethodsAnnotations(): array
    {
        $annotations = [];
        foreach ($this->getAllAbilitiesList() as $abilities) {
            /** @var AbilityMethod $ability */
            foreach ($abilities as $ability) {
                $parametersHint = [];
                foreach ($ability->methodParameters as $methodParameter) {
                    $hint = '';
                    if ($methodParameter->getType()) {
                        if (class_exists($methodParameter->getType()->getName())) {
                            $hint .=  '\\' . ltrim($methodParameter->getType()->getName(), '\\');
                        } else {
                            $hint .= $methodParameter->getType()->getName();
                        }
                    }


                    $hint .= ' $' . $methodParameter->getName();
                    if ($methodParameter->isDefaultValueAvailable()) {
                        $hint .= ' = ' . var_export($methodParameter->getDefaultValue(), true);
                    }

                    $parametersHint[] = $hint;
                }
                $returnHint = '';
                if ($ability->methodReturnType) {
                    if (class_exists($ability->methodReturnType->getName())) {
                        $returnHint .= '\\' . ltrim($ability->methodReturnType->getName(), '\\');
                    } else {
                        $returnHint .= $ability->methodReturnType->getName();
                    }
                }
                $annotations[] = sprintf(
                    '@method static %s %s(%s)',
                    $returnHint,
                    $ability->methodName,
                    implode(', ', $parametersHint)
                );
            }
        }

        return $annotations;
    }

    public function buildAbilitiesArray(): array
    {
        $abilitiesArray = [];
        foreach ($this->getAllAbilitiesList() as $class => $abilities) {
            $classAbilities = '\\' . ltrim($class, '\\') . '::class' . ' => [' . PHP_EOL;
            foreach ($abilities as $ability) {
                $classAbilities .= "            '$ability->methodName'," . PHP_EOL;
            }
            $classAbilities .= '        ],';

            $abilitiesArray[] = $classAbilities;
        }

        return $abilitiesArray;
    }
}
